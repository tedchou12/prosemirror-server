var ref = require("./map");
var Mapping = ref.Mapping;

var TransformError = (function (Error) {
  function TransformError(message) { Error.call(this, message) }

  if ( Error ) TransformError.__proto__ = Error;
  TransformError.prototype = Object.create( Error && Error.prototype );
  TransformError.prototype.constructor = TransformError;

  var prototypeAccessors = { name: {} };
  prototypeAccessors.name.get = function () { return "TransformError" };

  Object.defineProperties( TransformError.prototype, prototypeAccessors );

  return TransformError;
}(Error));
exports.TransformError = TransformError

// ::- Abstraction to build up and track such an array of
// [steps](#transform.Step).
//
// The high-level transforming methods return the `Transform` object
// itself, so that they can be chained.
var Transform = function Transform(doc) {
  // :: Node
  // The current document (the result of applying the steps in the
  // transform).
  this.doc = doc
  // :: [Step]
  // The steps in this transform.
  this.steps = []
  // :: [Node]
  // The documents before each of the steps.
  this.docs = []
  // :: Mapping
  // A mapping with the maps for each of the steps in this transform.
  this.mapping = new Mapping
};

var prototypeAccessors$1 = { before: {},docChanged: {} };

// :: Node The document at the start of the transformation.
prototypeAccessors$1.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };

// :: (step: Step) → this
// Apply a new step in this transformation, saving the result.
// Throws an error when the step fails.
Transform.prototype.step = function step (object) {
  var result = this.maybeStep(object)
  if (result.failed) { throw new TransformError(result.failed) }
  return this
};

// :: (Step) → StepResult
// Try to apply a step in this transformation, ignoring it if it
// fails. Returns the step result.
Transform.prototype.maybeStep = function maybeStep (step) {
  var result = step.apply(this.doc)
  if (!result.failed) { this.addStep(step, result.doc) }
  return result
};

// :: bool
// True when this transaction changes the document.
prototypeAccessors$1.docChanged.get = function () {
  return this.steps.length > 0
};

Transform.prototype.addStep = function addStep (step, doc) {
  this.docs.push(this.doc)
  this.steps.push(step)
  this.mapping.appendMap(step.getMap())
  this.doc = doc
};

Object.defineProperties( Transform.prototype, prototypeAccessors$1 );
exports.Transform = Transform
